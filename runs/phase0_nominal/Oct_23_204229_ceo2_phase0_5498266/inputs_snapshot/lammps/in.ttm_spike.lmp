# --- TTM spike stage: NVE on interior + USER-TTM electrons ---
print "=== TTM spike stage: NVE (interior) + USER-TTM electron field ===" append yes

# Interior = all atoms minus the x/y rim sponge from rim_langevin.in
group interior subtract all rim

# For logging only (used for Te Gaussian width)
variable r0_A equal ${R0}*10.0
print "TTM source (init via Te.in): r0 = ${R0} nm = ${r0_A} A ; Se = ${SE} eV/A ; g0 = ${G0} W/m^3/K" append yes

# Lattice integrator
fix f_nve interior nve

# --- USER-TTM grid sizing (starter ~1.0 A spacing; tune in Phase 2) ---
# Use integer aliases for grid sizes and reuse them everywhere
variable iNX equal ceil(lx/1.0)
variable iNY equal ceil(ly/1.0)
variable iNZ equal ceil(lz/1.0)

# Nominal electron parameters in metal units (placeholders to get the pipeline running)
#   CE0: eV/(electron*K),  RHOE0: electrons/A^3,
#   KE0: eV/(ps*A*K),      GP: mass/ps, GS: mass/ps, V0: A/ps
variable CE0    equal 1.0
variable RHOE0  equal 1.0
variable KE0    equal 1.0
variable GP     equal 1.0e-4
variable GS     equal 0.0
variable V0     equal 1.0

# --- Build a cylindrical Gaussian Te field on the TTM grid and write Te.in ---
# File path to write
variable TEF string ${OUTDIR}/post/Te.in
shell rm -f ${TEF}

# Target Te profile parameters (adjust later if needed)
variable TE_BASE  equal 300.0          # K, far-field electron temperature
variable TE_CORE  equal 5000.0         # K, on-axis peak electron temperature
variable sigma_A  equal ${r0_A}/sqrt(2.0)  # Gaussian sigma so that r0 ~ sqrt(2)*sigma

# Loop over 1-based grid indices and write "ix iy iz Te"
variable ix loop ${iNX}
label loop_ix
  variable iy loop ${iNY}
  label loop_iy
    variable iz loop ${iNZ}
    label loop_iz
      # Grid-node center coords relative to box center (A) â€” keep expressions as single tokens
      variable dx equal lx/v_iNX
      variable dy equal ly/v_iNY
      variable x_i equal (v_ix-0.5)*v_dx-0.5*lx
      variable y_i equal (v_iy-0.5)*v_dy-0.5*ly
      variable r2  equal v_x_i*v_x_i+v_y_i*v_y_i
      variable Te  equal v_TE_BASE+(v_TE_CORE-v_TE_BASE)*exp(-v_r2/(2.0*v_sigma_A*v_sigma_A))
      print "${ix} ${iy} ${iz} ${Te}" file ${TEF} screen no append yes
      next iz
    jump SELF loop_iz
    next iy
  jump SELF loop_iy
  next ix
jump SELF loop_ix

# Sanity: show expected vs actual line count
variable expected equal v_iNX*v_iNY*v_iNZ
print "Te.in expected_lines=${expected}" screen yes
shell wc -l ${TEF}
shell sync

# One and only one ttm/grid fix; seed must be a positive integer
fix f_ttm interior ttm/grid 12345 ${CE0} ${RHOE0} ${KE0} ${GP} ${GS} ${V0} ${iNX} ${iNY} ${iNZ} infile ${TEF}

# Initialize computes/thermo after adding fixes
run 0 post no

# Spike length: default NSTEPS minus equilibration steps (neq is always defined in in.main.lmp)
variable nspike equal ${NSTEPS}-${neq}
print "Spike steps (nspike) = ${nspike}" append yes

# Dump during the spike: positions + velocities (needed for Tl core)
dump dspike all custom 100 ${OUTDIR}/dumps/atoms.spike.*.lammpstrj id type x y z vx vy vz q
dump_modify dspike sort id

# Run the spike
run ${nspike}
undump dspike

# Cleanup
unfix f_nve
unfix f_ttm

print "=== Spike complete; end of Phase 0 nominal shot ===" append yes
