# --- TTM spike stage: NVE on interior + USER-TTM electrons ---
print "=== TTM spike stage: NVE (interior) + USER-TTM electron field ===" append yes

# Interior = all atoms minus the x/y rim sponge from rim_langevin.in
group interior subtract all rim

# For logging only (used for Te Gaussian width)
variable r0_A equal ${R0}*10.0
print "TTM source (init via Te.in): r0 = ${R0} nm = ${r0_A} A ; Se = ${SE} eV/A ; g0 = ${G0} W/m^3/K" append yes

# Lattice integrator
fix f_nve interior nve

# --- USER-TTM grid sizing (starter ~1.0 A spacing; tune in Phase 2) ---
# Integer aliases; use consistently for loops and fix args
variable iNX equal ceil(lx/1.0)
variable iNY equal ceil(ly/1.0)
variable iNZ equal ceil(lz/1.0)

# Nominal electron parameters in metal units (Phase-0 placeholders)
#   CE0: eV/(electron*K),  RHOE0: electrons/A^3,
#   KE0: eV/(ps*A*K),      GP: mass/ps, GS: mass/ps, V0: A/ps
variable CE0    equal 1.0
variable RHOE0  equal 1.0
variable KE0    equal 1.0
variable GP     equal 1.0e-4
variable GS     equal 0.0
variable V0     equal 1.0

# --- Build a cylindrical Gaussian Te field on the TTM grid and write Te.in ---
variable TEF string ${OUTDIR}/post/Te.in
shell rm -f ${TEF}

# Target Te profile parameters (adjust if needed)
variable TE_BASE  equal 300.0
variable TE_CORE  equal 5000.0
variable sigma_A  equal ${r0_A}/sqrt(2.0)   # r0 ≈ √2·sigma

# Cell sizes (A)
variable dx equal lx/v_iNX
variable dy equal ly/v_iNY

# Flattened loop over all grid nodes: idx = 1 .. iNX*iNY*iNZ
variable nlines equal v_iNX*v_iNY*v_iNZ
variable idx loop ${nlines}
label loop_all
  # 0-based flat index
  variable i equal v_idx-1
  # Integer arithmetic to recover 1-based ix,iy,iz
  # mod(x,y) -> remainder; floor() is integer division
  variable ix equal fmod(v_i,v_iNX)+1
  variable iy equal fmod(floor(v_i/v_iNX),v_iNY)+1
  variable iz equal floor(v_i/(v_iNX*v_iNY))+1

  # node centers relative to box center (single-token expressions)
  variable x_i equal (v_ix-0.5)*v_dx-0.5*lx
  variable y_i equal (v_iy-0.5)*v_dy-0.5*ly
  variable r2  equal v_x_i*v_x_i+v_y_i*v_y_i
  variable Te  equal v_TE_BASE+(v_TE_CORE-v_TE_BASE)*exp(-v_r2/(2.0*v_sigma_A*v_sigma_A))

  # write one line: "ix iy iz Te"
  print "${ix} ${iy} ${iz} ${Te}" file ${TEF} screen no append yes

  next idx
jump SELF loop_all

# Sanity: expected vs actual Te.in line count
print "Te.in expected_lines=${nlines}" screen yes
shell wc -l ${TEF}
shell sync

# One and only one ttm/grid fix; seed must be a positive integer
fix f_ttm interior ttm/grid 12345 ${CE0} ${RHOE0} ${KE0} ${GP} ${GS} ${V0} ${iNX} ${iNY} ${iNZ} infile ${TEF}

# Initialize computes/thermo after adding fixes
run 0 post no

# Spike length: NSTEPS - neq  (neq is defined in in.main.lmp)
variable nspike equal ${NSTEPS}-${neq}
print "Spike steps (nspike) = ${nspike}" append yes

# Dump during the spike (for analyses)
dump dspike all custom 100 ${OUTDIR}/dumps/atoms.spike.*.lammpstrj id type x y z vx vy vz q
dump_modify dspike sort id

# Run the spike
run ${nspike}
undump dspike

# Cleanup
unfix f_nve
unfix f_ttm

print "=== Spike complete; end of Phase 0 nominal shot ===" append yes
